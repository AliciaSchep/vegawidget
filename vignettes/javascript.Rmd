---
title: "Extend using JavaScript"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
---

```{r}
library("vegawidget")
library("htmltools")
```

The purpose of this article is to show how you can use JavaScript to extend Vega's capabilities. In these examples, we use the [vega-view](https://github.com/vega/vega/tree/master/packages/vega-view) API to interact with a Vega chart using JavaScript. We explore similar ideas in an article on [extending using Shiny](shiny.Rmd).

Using the vega-view API, there are three things we will focus on for this article:

- setting (and soon getting) [datasets](#data) 
- setting and getting signals
- getting events

## Demo: setting (and soon getting) datasets {#data}

[Vega](https://vega.github.io/vega/docs/data/) and [Vega-Lite](https://vega.github.io/vega-lite/docs/data.html#named) both offer the ability to name datasets within a specification. 

We can use the vega-view API to [change a dataset](https://vega.github.io/vega/docs/api/view/#data-and-scales), and in a future version of this package, you will be able to listen to a dataset, i.e. to specify an action whenever a dataset changes.

Let's consider an example with a dataset that has a single observation, and that we can use an HTML input to change that observation.

First, we use the `tags` environment from the **htmltools** package to create a range input that we use to specify an angle - in our case 0 to 360 degrees. Our input is named `"angle"`.

```{r}
input_angle <- tags$input(
  type = "range", 
  name = "angle", 
  value = 0, 
  min = 0, 
  max = 360, 
  step = 1,
  style = "width: 400px; margin-bottom: 10px;"
)
```

Next, we create a specification, then a vegawidget with an `elementId` of `"circle"`

```{r}
spec_circle <- 
  list(
    `$schema` = vega_schema(),
    width = 300,
    height = 300,
    data = list(
      values = list(x = 1, y = 0),
      name = "source"
    ),
    mark = "point",
    encoding = list(
      x = list(
        field = "x", 
        type = "quantitative", 
        scale = list(domain = list(-1, 1))
      ),
      y = list(
        field = "y", 
        type = "quantitative", 
        scale = list(domain = list(-1, 1))
      )     
    )
  ) %>%
  as_vegaspec()

output_chart <- vegawidget(spec_circle, elementId = "circle")
```

Let's print out our HTML elements to the document, then we will add some JavaScript to define the interactions:

```{r}
input_angle

output_chart
```

Our first job is to create a JavaScript variable that refers to the input slider we created above; we call it `inp_angle` to keep it distinct (in our heads) from the R varaible `input_angle`. Please note that the next few code-chunks are `{js}` chunks rather than `{r}` chunks.

```{js}
// this is a {js} chunk

// JS reference to our slider-input
var inp_angle = document.querySelector("[name=angle]");
```

Next, we create a JavaScript function that, when run, reads the value of the input-slider, then updates the dataset in the Vega chart. This function has no arguments; instead, it refers-to and *changes* variables in the JavaScript environment.

The first part of the function converts the value of `inp_andgle` into a dataset, `data_new`, with a single observation. The second part of the function modifies the chart. This package puts an object into JavaScript's global namespace, `Vegawidget`, which contains a function `findViewPromise()`. We use this function with a single argument, a css `selector`, to specify the HTML element that contains the chart we wish to access. The `findVewPromise()` function returns a JavaScript [promise](https://javascript.info/promise-basics) to which we supply a function with a single argument, the `view` of the chart we are accessing.

The `view` is the object of the [vega-view API](https://github.com/vega/vega/tree/master/packages/vega-view#view-api-reference). Here, we create a changeset inserting `data_new` and removing any existing data, then we [change](https://github.com/vega/vega/tree/master/packages/vega-view#view_change) the view's dataset named `"source"`, then we [run](https://github.com/vega/vega/tree/master/packages/vega-view#view_run) the view.

```{js}
function on_angle() {

  // translate the input value to x-y coordinates in a new dataset
  var theta = inp_angle.value * Math.PI / 180;
  var data_new = [{x: Math.cos(theta), y: Math.sin(theta)}];

  // changes Vega chart
  Vegawidget.findViewPromise("#circle").then(function(view) {
    var changeSet = vega.changeset()
                        .insert(data_new)
                        .remove(vega.truthy);
                          
    view.change("source", changeSet).run();  
  });  

}
```

Finally, we specify when our `on_angle()` function should run: we [add an event listener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) to `input_angle` so that the function runs whenever `input_angle` changes, we run the function *once* at initialization. 

```{js}
// whenever the input changes, run the updating function
inp_angle.addEventListener("input", on_angle);

// run the updating function *once* to initialize the input to the data
on_angle()
```

In a future release of this package, we will be able to listen to (and extract) datasets in a Vega chart.

## Demo: streaming data

Here, we recreate this Vega-Lite [streaming tutorial](https://vega.github.io/vega-lite/tutorials/streaming.html). In this case we are using JavaScript both to create the new data, and to update the dataset in Vega.

The point of the original Vega-Lite demo is to show how to use the [vega-view](https://github.com/vega/vega/tree/master/packages/vega-view) API to modify a chart once it has been rendered. The point of this demo is to show the steps you can take to adapt the original Vega-Lite demo to the htmlwidgets context.
 
Our first step is to create a vegaspec. Note that we have named a dataset to `"table"`, but we have not included any data.

```{r}
spec_table <-
  list(
    `$schema` = vega_schema(),
    width = 400,
    data = list(name = "table"),
    mark = "line",
    encoding = list(
      x = list(
        field = "x", 
        type = "quantitative",
        scale = list(zero =  FALSE)
      ),
      y = list(field = "y", type = "quantitative"),
      color = list(field = "category", type = "nominal")
    )
  ) %>%
  as_vegaspec()
```

We use `vegawidget()` function with an `elementId` argument, to specify the id of the HTML element. This argument is not documented as a part of `vegawidget()`; rather it is passed on to `htmlwidget::createWidget()` using `...`. We need to specify this so that the JavaScript code we write later will know which Vega chart to modify. 

```{r}
vegawidget(spec_table, elementId = "streaming-demo")
```

In the absence of the code below, we would be left with an empty chart. Note that this is written in JavaScript - in the R Markdown file, this is a `{js}` chunk, rather than an `{r}` chunk. 

TODO: Describe the `Vegawidget.find()` function, that it returns a promise to a vegawidget object, then you get the veg promise from it, and so on...

In the demo code, the `vegaEmbed()` function (described in the [vega-embed](https://github.com/vega/vega-embed) library) returns a promise object, a JavaScript object used for asynchronous execution. We do not have direct access to the creation of the promise in the HTML file, but the vegawidget JavaScript API provides a function `getVegaPromise()` that, given a CSS selector to find the enclosing element (hence the `elementId = "table"` earlier), returns the promise.

The `.then()` call contains a function that takes a single argument, `result` - this is our promise object. A  [`vegaEmbed()`](https://github.com/vega/vega-embed#embed) promise object contains two objects: a [`view`](https://github.com/vega/vega/tree/master/packages/vega-view) instance and a copy of the `spec` used to create it. Although we are likely interested only in the view, we follow the vega-embed convention to return the entire object so that you refer to the view in the function as `result.view`.

The rest of the code is copied from the original demonstration. To change a dataset, we use vega-view's [change](https://github.com/vega/vega/tree/master/packages/vega-view#view_change) method.

```{js}
// This is a JavaScript chunk, using {js} instead of {r}
Vegawidget.findViewPromise('#streaming-demo').then(function(view) {
  /**
   * Generates a new tuple with random walk.
   */
  function newGenerator() {
      var counter = -1;
      var previousY = [5, 5, 5, 5];
      return function () {
          counter++;
          var newVals = previousY.map(function (v, c) { return ({
              x: counter,
              y: v + Math.round(Math.random() * 10 - c * 3),
              category: c
          }); });
          previousY = newVals.map(function (v) { return v.y; });
          return newVals;
      };
  }

  var valueGenerator = newGenerator();
  var minimumX = -100;
  window.setInterval(function () {
      minimumX++;
      var data_insert = valueGenerator();
      var data_remove = function(data_remove) {
        return (data_remove.x < minimumX);
      };
      
      var changeSet = vega.changeset()
                          .insert(valueGenerator())
                          .remove(function (t) { return t.x < minimumX; });
                          
      view.change('table', changeSet).run();
  }, 1000);  
});
```



