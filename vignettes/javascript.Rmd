---
title: "Extend using JavaScript"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
---

```{r}
library("vegawidget")
```

The purpose of this article is to show how you can use JavaScript to extend Vega's capabilities. In these examples, we use the [vega-view](https://github.com/vega/vega/tree/master/packages/vega-view) API to update the dataset using JavaScript. Clearly, this approach is not as intuitive as using Shiny, but it could be useful in situations where Shiny is not available or feasible.

## Demo: streaming data

Here, we recreate this Vega-Lite [streaming tutorial](https://vega.github.io/vega-lite/tutorials/streaming.html). In this case we are using JavaScript both to create the new data, and to update the dataset in Vega.

The point of the original Vega-Lite demo is to show how to use the [vega-view](https://github.com/vega/vega/tree/master/packages/vega-view) API to modify a chart once it has been rendered. The point of this demo is to show the steps you can take to adapt the original Vega-Lite demo to the htmlwidgets context.
 
Our first step is to create a vegaspec. Note that we have named a dataset to `"table"`, but we have not included any data.

```{r}
spec_table <-
  list(
    `$schema` = vega_schema(),
    width = 400,
    data = list(name = "table"),
    mark = "line",
    encoding = list(
      x = list(
        field = "x", 
        type = "quantitative",
        scale = list(zero =  FALSE)
      ),
      y = list(field = "y", type = "quantitative"),
      color = list(field = "category", type = "nominal")
    )
  ) %>%
  as_vegaspec()
```

We use `vegawidget()` function with an `elementId` argument, to specify the id of the HTML element. This argument is not documented as a part of `vegawidget()`; rather it is passed on to `htmlwidget::createWidget()` using `...`. We need to specify this so that the JavaScript code we write later will know which Vega chart to modify. 

```{r}
vegawidget(spec_table, elementId = "streaming-demo")
```

In the absence of the code below, we would be left with an empty chart. Note that this is written in JavaScript - in the R Markdown file, this is a `{js}` chunk, rather than an `{r}` chunk. 

TODO: Describe the `Vegawidget.find()` function, that it returns a promise to a vegawidget object, then you get the veg promise from it, and so on...

In the demo code, the `vegaEmbed()` function (described in the [vega-embed](https://github.com/vega/vega-embed) library) returns a promise object, a JavaScript object used for asynchronous execution. We do not have direct access to the creation of the promise in the HTML file, but the vegawidget JavaScript API provides a function `getVegaPromise()` that, given a CSS selector to find the enclosing element (hence the `elementId = "table"` earlier), returns the promise.

The `.then()` call contains a function that takes a single argument, `result` - this is our promise object. A  [`vegaEmbed()`](https://github.com/vega/vega-embed#embed) promise object contains two objects: a [`view`](https://github.com/vega/vega/tree/master/packages/vega-view) instance and a copy of the `spec` used to create it. Although we are likely interested only in the view, we follow the vega-embed convention to return the entire object so that you refer to the view in the function as `result.view`.

The rest of the code is copied from the original demonstration. To change a dataset, we use vega-view's [change](https://github.com/vega/vega/tree/master/packages/vega-view#view_change) method.

```{js}
// This is a JavaScript chunk, using {js} instead of {r}
Vegawidget.findViewPromise('#streaming-demo').then(function(view) {
  /**
   * Generates a new tuple with random walk.
   */
  function newGenerator() {
      var counter = -1;
      var previousY = [5, 5, 5, 5];
      return function () {
          counter++;
          var newVals = previousY.map(function (v, c) { return ({
              x: counter,
              y: v + Math.round(Math.random() * 10 - c * 3),
              category: c
          }); });
          previousY = newVals.map(function (v) { return v.y; });
          return newVals;
      };
  }

  var valueGenerator = newGenerator();
  var minimumX = -100;
  window.setInterval(function () {
      minimumX++;
      var data_insert = valueGenerator();
      var data_remove = function(data_remove) {
        return (data_remove.x < minimumX);
      };
      
      var changeSet = vega.changeset()
                          .insert(valueGenerator())
                          .remove(function (t) { return t.x < minimumX; });
                          
      view.change('table', changeSet).run();
  }, 1000);  
});
```

## Demo: externally-driven data

This is an adaptation of an [Observable notebook](https://beta.observablehq.com/@ijlyttle/using-changesets-with-vega-lite). The goal here is to show how you can update the data using an external source, like an input. Although we can do this using JavaScript only, the process is not nearly as straightforward as using Shiny. However, this may be useful in cases where it is not feasible to use Shiny.

We will use the **htmltools** package to generate our HTML elements. 

```{r}
library("htmltools")
```

We create a range input that we use to specify an angle - in our case 0 to 360 degrees. Our input is named `"angle"`.

```{r}
input_angle <- tags$input(
  type = "range", 
  name = "angle", 
  value = 0, 
  min = 0, 
  max = 360, 
  step = 1,
  style = "width: 400px; margin-bottom: 10px;"
)
```

We then create our vegaspec and our vegawidget output, using a named dataset called `"source"`. Our chart will be inside an element called `"circle"`

```{r}
spec_circle <- 
  list(
    `$schema` = vega_schema(),
    width = 300,
    height = 300,
    data = list(
      values = list(x = 1, y = 0),
      name = "source"
    ),
    mark = "point",
    encoding = list(
      x = list(
        field = "x", 
        type = "quantitative", 
        scale = list(domain = list(-1, 1))
      ),
      y = list(
        field = "y", 
        type = "quantitative", 
        scale = list(domain = list(-1, 1))
      )     
    )
  ) %>%
  as_vegaspec()

output_chart <- vegawidget(spec_circle, elementId = "circle")
```

Finally, we create a text output just so that we can see our data object - its id is `"text"`. Note that we put in some dummy text that will be written-over later.

```{r}
output_text <- tags$div(
  id = "text", 
  style = "font-family: monospace; margin-bottom: 10px;",
  "Look here for live data"
)
```

Having created our elements, we print them into our document:

```{r}
output_chart
```

```{r}
input_angle
```

```{r}
output_text
```

It remains to define the interaction among the elements, using JavaScript:

```{js}
// this is a {js} chunk

// JS reference to our slider-input
var input_angle = document.querySelector("[name=angle]");

// updates the chart and the text output according to the input value
function on_angle() {

  // translate the input value to x-y coordinates in a new dataset
  var theta = input_angle.value * Math.PI / 180;
  var data_live = [{x: Math.cos(theta), y: Math.sin(theta)}];

  // changes output-text value to show the coordinates
  document.querySelector("#text").innerHTML = JSON.stringify(data_live);
  
  // changes Vega chart
  Vegawidget.findViewPromise("#circle").then(function(view) {
    var changeSet = vega.changeset()
                        .insert(data_live)
                        .remove(vega.truthy);
                          
    view.change("source", changeSet).run();  
  });  

}

// whenever the input changes, run the updating function
input_angle.addEventListener("input", on_angle);

// run the updating function *once* to initialize the input to the data
on_angle()
```
